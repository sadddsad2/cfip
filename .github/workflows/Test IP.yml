name: Test IP Connectivity and Create Release

on:
  schedule:
    - cron: '0 19 * * *'  # æ¯å¤©åŒ—äº¬æ—¶é—´å‡Œæ™¨3ç‚¹è¿è¡Œ (UTC 19:00 = åŒ—äº¬æ—¶é—´ 03:00)
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘
  push:
    branches:
      - main
    paths:
      - '.github/workflows/ip-test.yml'
      - 'api.txt'

# æ·»åŠ å¿…è¦çš„æƒé™
permissions:
  contents: write  # å…è®¸åˆ›å»º Release å’Œä¸Šä¼ æ–‡ä»¶
  actions: read

jobs:
  test-and-release:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        pip install requests aiohttp asyncio

    - name: Verify api.txt exists
      run: |
        if [ ! -f api.txt ]; then
          echo "âŒ api.txt æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»ºç¤ºä¾‹æ–‡ä»¶..."
          cat > api.txt << 'APIEOF'
        # API åˆ—è¡¨é…ç½®æ–‡ä»¶
        # æ¯è¡Œä¸€ä¸ª API åœ°å€ï¼Œ# å¼€å¤´çš„è¡Œä¸ºæ³¨é‡Š
        # 
        # CloudFlare IP ä¼˜é€‰ API
        https://raw.githubusercontent.com/ymyuuu/IPDB/refs/heads/main/bestproxy.txt
        https://raw.githubusercontent.com/ymyuuu/IPDB/refs/heads/main/bestcf.txt
        https://ip.164746.xyz/ipTop10.html
        https://raw.githubusercontent.com/ZhiXuanWang/cf-speed-dns/refs/heads/main/ipTop10.html
        https://vps789.com/public/sum/cfIpApi
        # https://www.wetest.vip/api/cf2dns/get_cloudflare_ip&type=v4&key=o1zrmHAF
        https://raw.githubusercontent.com/cmliu/WorkerVless2sub/main/addressesapi.txt
        https://addressesapi.090227.xyz/CloudFlareYes
        https://addressesapi.090227.xyz/ip.164746.xyz
        APIEOF
          echo "âœ… å·²åˆ›å»ºç¤ºä¾‹ api.txt æ–‡ä»¶"
        fi
        echo "ğŸ“‹ API åˆ—è¡¨å†…å®¹ï¼š"
        cat api.txt

    - name: Create test script
      run: |
        cat > test_ip.py << 'EOF'
        import asyncio
        import aiohttp
        import json
        import re
        import socket
        from datetime import datetime
        from typing import List, Dict, Optional, Tuple
        import time
        import os

        # å›½å®¶ä»£ç æ˜ å°„
        COUNTRY_MAPPING = {
            'CN': 'ä¸­å›½', 'HK': 'é¦™æ¸¯', 'TW': 'å°æ¹¾', 'JP': 'æ—¥æœ¬', 'KR': 'éŸ©å›½',
            'SG': 'æ–°åŠ å¡', 'MY': 'é©¬æ¥è¥¿äºš', 'TH': 'æ³°å›½', 'VN': 'è¶Šå—', 'ID': 'å°å°¼',
            'IN': 'å°åº¦', 'PH': 'è²å¾‹å®¾', 'US': 'ç¾å›½', 'CA': 'åŠ æ‹¿å¤§', 'MX': 'å¢¨è¥¿å“¥',
            'DE': 'å¾·å›½', 'GB': 'è‹±å›½', 'FR': 'æ³•å›½', 'IT': 'æ„å¤§åˆ©', 'ES': 'è¥¿ç­ç‰™',
            'PT': 'è‘¡è„ç‰™', 'NL': 'è·å…°', 'BE': 'æ¯”åˆ©æ—¶', 'SE': 'ç‘å…¸', 'NO': 'æŒªå¨',
            'AU': 'æ¾³å¤§åˆ©äºš', 'NZ': 'æ–°è¥¿å…°', 'BR': 'å·´è¥¿', 'AR': 'é˜¿æ ¹å»·', 'RU': 'ä¿„ç½—æ–¯',
            'CH': 'ç‘å£«', 'AT': 'å¥¥åœ°åˆ©', 'DK': 'ä¸¹éº¦', 'FI': 'èŠ¬å…°', 'IE': 'çˆ±å°”å…°',
            'PL': 'æ³¢å…°', 'CZ': 'æ·å…‹', 'TR': 'åœŸè€³å…¶', 'AE': 'é˜¿è”é…‹', 'IL': 'ä»¥è‰²åˆ—',
            'ZA': 'å—é', 'EG': 'åŸƒåŠ', 'SA': 'æ²™ç‰¹', 'UA': 'ä¹Œå…‹å…°', 'GR': 'å¸Œè…Š'
        }

        def load_api_list(filename: str = 'api.txt') -> List[str]:
            """ä» api.txt åŠ è½½ API åˆ—è¡¨"""
            api_urls = []
            
            if not os.path.exists(filename):
                print(f"âŒ {filename} æ–‡ä»¶ä¸å­˜åœ¨")
                return api_urls
            
            with open(filename, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    # å¿½ç•¥ç©ºè¡Œå’Œ # å¼€å¤´çš„æ³¨é‡Šè¡Œ
                    if line and not line.startswith('#'):
                        api_urls.append(line)
            
            print(f"âœ… ä» {filename} åŠ è½½äº† {len(api_urls)} ä¸ª API")
            return api_urls

        def is_valid_ip(ip: str) -> bool:
            """éªŒè¯IPåœ°å€æ ¼å¼"""
            parts = ip.split('.')
            if len(parts) != 4:
                return False
            for part in parts:
                try:
                    num = int(part)
                    if num < 0 or num > 255:
                        return False
                    if len(part) > 1 and part[0] == '0':
                        return False
                except ValueError:
                    return False
            return True

        def is_valid_port(port: str) -> bool:
            """éªŒè¯ç«¯å£å·æ ¼å¼"""
            try:
                num = int(port)
                return 0 < num <= 65535
            except ValueError:
                return False

        def parse_ip_line(line: str) -> Optional[Dict]:
            """è§£æIPè¡Œï¼Œæ”¯æŒå¤šç§æ ¼å¼"""
            line = line.strip()
            
            # è·³è¿‡æ— æ•ˆè¡Œ
            if not line or line.startswith(('#', '//', '<!--', 'http')):
                return None
            
            # æ¨¡å¼1: IP:Port#Country
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)#(.+)$', line)
            if match:
                ip, port, country = match.groups()
                if is_valid_ip(ip) and is_valid_port(port):
                    return {'ip': ip, 'port': port, 'country': country.strip()}
            
            # æ¨¡å¼2: IP#Country
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})#(.+)$', line)
            if match:
                ip, country = match.groups()
                if is_valid_ip(ip):
                    return {'ip': ip, 'port': '443', 'country': country.strip()}
            
            # æ¨¡å¼3: IP:Port
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)', line)
            if match:
                ip, port = match.groups()
                if is_valid_ip(ip) and is_valid_port(port):
                    return {'ip': ip, 'port': port, 'country': None}
            
            # æ¨¡å¼4: å•ç‹¬IP
            match = re.match(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$', line)
            if match:
                ip = match.group(1)
                if is_valid_ip(ip):
                    return {'ip': ip, 'port': '443', 'country': None}
            
            return None

        async def fetch_url(session: aiohttp.ClientSession, url: str) -> str:
            """å¼‚æ­¥è·å–URLå†…å®¹"""
            try:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=30)) as response:
                    if response.status == 200:
                        return await response.text()
                    else:
                        print(f"âš ï¸  {url} è¿”å›çŠ¶æ€ç : {response.status}")
            except asyncio.TimeoutError:
                print(f"â±ï¸  {url} è¯·æ±‚è¶…æ—¶")
            except Exception as e:
                print(f"âŒ è·å– {url} å¤±è´¥: {e}")
            return ""

        async def get_ip_country(session: aiohttp.ClientSession, ip: str) -> str:
            """è·å–IPå½’å±åœ°"""
            try:
                async with session.get(f'https://ipinfo.io/{ip}/json', 
                                      timeout=aiohttp.ClientTimeout(total=10)) as response:
                    if response.status == 200:
                        data = await response.json()
                        country_code = data.get('country', 'Unknown')
                        return COUNTRY_MAPPING.get(country_code, country_code)
            except Exception:
                pass
            return 'Unknown'

        def test_tcp_connectivity(ip: str, port: int, timeout: float = 3.0) -> bool:
            """æµ‹è¯•TCPè¿æ¥"""
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                result = sock.connect_ex((ip, port))
                sock.close()
                return result == 0
            except Exception:
                return False

        async def test_ip_connectivity(ip_data: Dict, session: aiohttp.ClientSession) -> Optional[Dict]:
            """æµ‹è¯•å•ä¸ªIPçš„è¿é€šæ€§"""
            ip = ip_data['ip']
            port = int(ip_data['port'])
            
            print(f"ğŸ” æµ‹è¯• {ip}:{port}...", end=' ')
            
            # æµ‹è¯•è¿é€šæ€§
            is_connected = test_tcp_connectivity(ip, port, timeout=5.0)
            
            if not is_connected:
                print("âŒ æ— æ³•è¿æ¥")
                return None
            
            print("âœ… è¿æ¥æˆåŠŸ", end=' ')
            
            # è·å–å›½å®¶ä¿¡æ¯
            country = ip_data.get('country')
            if not country or country == 'Unknown':
                country = await get_ip_country(session, ip)
                print(f"ğŸ“ {country}")
            else:
                print(f"ğŸ“ {country}")
            
            return {
                'ip': ip,
                'port': port,
                'country': country
            }

        async def main():
            print("=" * 60)
            print("ğŸš€ å¼€å§‹æµ‹è¯• IP è¿é€šæ€§")
            print("=" * 60)
            
            # ä» api.txt åŠ è½½ API åˆ—è¡¨
            api_urls = load_api_list('api.txt')
            
            if not api_urls:
                print("âŒ æ²¡æœ‰å¯ç”¨çš„ APIï¼Œè¯·æ£€æŸ¥ api.txt æ–‡ä»¶")
                return
            
            all_ips = []
            seen_ips = set()
            
            # æ”¶é›†æ‰€æœ‰IP
            async with aiohttp.ClientSession() as session:
                print(f"\nğŸ“¥ æ­£åœ¨ä» {len(api_urls)} ä¸ª API è·å– IP åˆ—è¡¨...")
                print("-" * 60)
                
                for idx, api_url in enumerate(api_urls, 1):
                    print(f"[{idx}/{len(api_urls)}] {api_url}")
                    content = await fetch_url(session, api_url)
                    
                    if not content:
                        continue
                    
                    lines = content.split('\n')
                    count_before = len(all_ips)
                    
                    for line in lines:
                        ip_data = parse_ip_line(line)
                        if ip_data and ip_data['ip'] not in seen_ips:
                            seen_ips.add(ip_data['ip'])
                            all_ips.append(ip_data)
                    
                    new_ips = len(all_ips) - count_before
                    if new_ips > 0:
                        print(f"  âœ… æ–°å¢ {new_ips} ä¸ª IP")
                    else:
                        print(f"  âš ï¸  æœªè·å–åˆ°æ–° IP")
                
                print("-" * 60)
                print(f"âœ… å…±æ”¶é›†åˆ° {len(all_ips)} ä¸ªå”¯ä¸€ IP")
                
                if len(all_ips) == 0:
                    print("âŒ æ²¡æœ‰æ”¶é›†åˆ°ä»»ä½• IPï¼Œè¯·æ£€æŸ¥ API æ˜¯å¦æ­£å¸¸")
                    with open('ip.txt', 'w', encoding='utf-8') as f:
                        f.write(f"# æµ‹è¯•æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                        f.write("# æœªæ”¶é›†åˆ°ä»»ä½• IP æ•°æ®\n")
                    return
                
                # æµ‹è¯•è¿é€šæ€§
                print("\nğŸ”„ å¼€å§‹æµ‹è¯•è¿é€šæ€§...")
                print("-" * 60)
                
                valid_ips = []
                
                # åˆ†æ‰¹å¤„ç†ï¼Œé¿å…å¹¶å‘è¿‡é«˜
                batch_size = 20
                for i in range(0, len(all_ips), batch_size):
                    batch = all_ips[i:i+batch_size]
                    batch_tasks = [test_ip_connectivity(ip_data, session) for ip_data in batch]
                    results = await asyncio.gather(*batch_tasks)
                    valid_ips.extend([r for r in results if r is not None])
                    
                    # è¿›åº¦æ˜¾ç¤º
                    progress = min(i + batch_size, len(all_ips))
                    print(f"\nğŸ“Š è¿›åº¦: {progress}/{len(all_ips)} ({progress*100//len(all_ips)}%) | å·²æ‰¾åˆ°å¯ç”¨ IP: {len(valid_ips)}")
                    print("-" * 60)
                    
                    # çŸ­æš‚å»¶è¿Ÿï¼Œé¿å…è¯·æ±‚è¿‡å¿«
                    await asyncio.sleep(0.5)
            
            print("\n" + "=" * 60)
            print(f"âœ… æµ‹è¯•å®Œæˆï¼")
            print(f"ğŸ“Š æ€»æµ‹è¯•æ•°: {len(all_ips)}")
            print(f"âœ… å¯è¿æ¥æ•°: {len(valid_ips)}")
            print(f"ğŸ“ˆ æˆåŠŸç‡: {len(valid_ips)*100//len(all_ips) if all_ips else 0}%")
            print("=" * 60)
            
            # å†™å…¥æ–‡ä»¶
            with open('ip.txt', 'w', encoding='utf-8') as f:
                # å†™å…¥å¤´éƒ¨ä¿¡æ¯
                f.write(f"# IP è¿é€šæ€§æµ‹è¯•ç»“æœ\n")
                f.write(f"# æµ‹è¯•æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"# æ€»æµ‹è¯•æ•°: {len(all_ips)}\n")
                f.write(f"# å¯è¿æ¥æ•°: {len(valid_ips)}\n")
                f.write(f"# æˆåŠŸç‡: {len(valid_ips)*100//len(all_ips) if all_ips else 0}%\n")
                f.write(f"# æ ¼å¼: IP:ç«¯å£#å›½å®¶åœ°åŒº\n")
                f.write("#" + "=" * 58 + "\n\n")
                
                if valid_ips:
                    # æŒ‰å›½å®¶åˆ†ç»„
                    by_country = {}
                    for ip_info in valid_ips:
                        country = ip_info['country']
                        if country not in by_country:
                            by_country[country] = []
                        by_country[country].append(ip_info)
                    
                    # å†™å…¥åˆ†ç»„åçš„IP
                    for country in sorted(by_country.keys()):
                        f.write(f"# {country} ({len(by_country[country])}ä¸ª)\n")
                        for ip_info in by_country[country]:
                            f.write(f"{ip_info['ip']}:{ip_info['port']}#{ip_info['country']}\n")
                        f.write("\n")
                    
                    print(f"\nğŸ’¾ ç»“æœå·²ä¿å­˜åˆ° ip.txt")
                    
                    # è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
                    print("\nğŸ“Š å›½å®¶/åœ°åŒºåˆ†å¸ƒ:")
                    for country, ips in sorted(by_country.items(), key=lambda x: len(x[1]), reverse=True):
                        print(f"  {country}: {len(ips)} ä¸ª")
                else:
                    f.write("# æœªæ‰¾åˆ°å¯è¿æ¥çš„ IP\n")
                    print("\nâš ï¸  æ²¡æœ‰æ‰¾åˆ°å¯è¿æ¥çš„ IP")

        if __name__ == '__main__':
            asyncio.run(main())
        EOF

    - name: Run IP connectivity test
      run: |
        python test_ip.py

    - name: Check if ip.txt exists and has valid data
      id: check_file
      run: |
        if [ -f ip.txt ]; then
          # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æœ‰å®é™…çš„IPæ•°æ®ï¼ˆæ’é™¤æ³¨é‡Šè¡Œï¼‰
          valid_lines=$(grep -v '^#' ip.txt | grep -E '^\s*[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | wc -l)
          
          if [ "$valid_lines" -gt 0 ]; then
            echo "file_exists=true" >> $GITHUB_OUTPUT
            echo "âœ… ip.txt æ–‡ä»¶å·²ç”Ÿæˆï¼ŒåŒ…å« $valid_lines ä¸ªæœ‰æ•ˆ IP"
            echo "ip_count=$valid_lines" >> $GITHUB_OUTPUT
          else
            echo "file_exists=false" >> $GITHUB_OUTPUT
            echo "âš ï¸  ip.txt æ–‡ä»¶å·²ç”Ÿæˆï¼Œä½†æ²¡æœ‰æœ‰æ•ˆçš„ IP æ•°æ®"
            echo "ip_count=0" >> $GITHUB_OUTPUT
          fi
          
          echo "ğŸ“„ æ–‡ä»¶å†…å®¹é¢„è§ˆ:"
          head -n 30 ip.txt
        else
          echo "file_exists=false" >> $GITHUB_OUTPUT
          echo "ip_count=0" >> $GITHUB_OUTPUT
          echo "âŒ ip.txt æ–‡ä»¶æœªç”Ÿæˆ"
        fi

    - name: Create Release
      if: steps.check_file.outputs.file_exists == 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ github.run_number }}-${{ github.run_id }}
        name: IP List ${{ github.run_number }} - ${{ steps.check_file.outputs.ip_count }} IPs
        body: |
          ## ğŸ“‹ IP è¿é€šæ€§æµ‹è¯•ç»“æœ
          
          **æµ‹è¯•æ—¶é—´:** `${{ github.event.repository.updated_at }}`  
          **è¿è¡Œç¼–å·:** #${{ github.run_number }}  
          **å¯ç”¨ IP æ•°é‡:** ${{ steps.check_file.outputs.ip_count }} ä¸ª
          
          ### ğŸ“Š æµ‹è¯•è¯´æ˜
          - âœ… æ‰€æœ‰ IP å‡å·²æµ‹è¯•ä¸ä¸­å›½å¤§é™†çš„è¿é€šæ€§
          - ğŸ“ åŒ…å« IP å½’å±åœ°ä¿¡æ¯ï¼ˆå›½å®¶/åœ°åŒºï¼‰
          - ğŸ“ æ ¼å¼: `IP:ç«¯å£#å›½å®¶åœ°åŒº`
          - ğŸ”„ æ¯å¤©åŒ—äº¬æ—¶é—´å‡Œæ™¨ 3 ç‚¹è‡ªåŠ¨æ›´æ–°
          
          ### ğŸ“¥ ä½¿ç”¨æ–¹æ³•
          1. ä¸‹è½½ `ip.txt` æ–‡ä»¶
          2. æŒ‰ç…§æ ¼å¼ä½¿ç”¨å…¶ä¸­çš„ IP åœ°å€
          3. æ¯ä¸ª IP éƒ½å·²éªŒè¯å¯è¿æ¥
          
          ### âš™ï¸ API æ¥æº
          IP æ•°æ®æ¥è‡ª `api.txt` æ–‡ä»¶ä¸­é…ç½®çš„ API æ¥å£
          
          ---
          *æ­¤ Release ç”± GitHub Actions è‡ªåŠ¨ç”Ÿæˆ ğŸ¤–*
        files: |
          ip.txt
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Keep only latest 5 releases
      if: steps.check_file.outputs.file_exists == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const releases = await github.rest.repos.listReleases({
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100
          });
          
          const sortedReleases = releases.data.sort((a, b) => 
            new Date(b.created_at) - new Date(a.created_at)
          );
          
          console.log(`Found ${sortedReleases.length} releases`);
          
          if (sortedReleases.length > 5) {
            for (let i = 5; i < sortedReleases.length; i++) {
              console.log(`Deleting release: ${sortedReleases[i].name} (${sortedReleases[i].tag_name})`);
              await github.rest.repos.deleteRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: sortedReleases[i].id
              });
              
              // åŒæ—¶åˆ é™¤å¯¹åº”çš„ tag
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${sortedReleases[i].tag_name}`
                });
                console.log(`Deleted tag: ${sortedReleases[i].tag_name}`);
              } catch (error) {
                console.log(`Could not delete tag: ${sortedReleases[i].tag_name}`);
              }
            }
            console.log(`âœ… Cleaned up ${sortedReleases.length - 5} old releases`);
          } else {
            console.log('âœ… No cleanup needed');
          }
